# 1.分类
    如果定义类在局部位置（方法中/代码块）：局部内部类 ， 匿名内部类(没有类名)
    定义在成员位置： 成员内部类 ， 静态内部类
# 2.基本介绍
    一个类的内部有完整的嵌套了另一个类的结构。被嵌套的类称为内部类（inner class）
    嵌套其他类的类称为外部类（outer class）。是我们类的五大成员【思考：类的五
    大成员是哪些？[属性，方法，构造器，代码块，内部类] ，内部类最大的特点就是可以
    直接访问私有属性，并且可以体现类与类之间的包含关系，注意：内部类是学习的难点，
    同时也是重点，后面看底层源码，有大量的内部类

# 3.局部内部类的使用
    说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。
    1.可以直接访问外部类的所有成员，包含私有的
    2.不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用
      修饰符的。都是可以使用final修饰，因为局部变量也可以使用final
    3.作用域：仅仅在定义他的方法或代码块中
    4.局部内部类---访问---->外部类的成员[访问方式：直接访问]
    5.外部类---访问---->局部内部类的成员[访问方式：
      创建对象，再访问（注意必须在作用域内）]
      记住：1）局部内部类定义在方法中/代码块
          2）作用域在方法体或者代码块中
          3）本质仍然是一个类
    6.外部其他类---不能访问---->局部内部类(因为局部内部类地位是一个局部变量)
    7.如果外部类和局部内部类的成员重名时，默认就近原则，如果想访问外部类的成员
      ，则可以使用(外部类名.this.成员）去访问
# 4.匿名内部类使用
    （1）本质是类（2）内部类（3）该类没名字（4）同时还是一个对象
        说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名
    1.语法：new 类或接口（参数列表）{类体};
    2.匿名内部类的语法比较奇特，请注意，因为匿名内部类既是一个类的定义，同时
      它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的
      的特征
    3.可以直接访问外部类的所有成员，包含私有的
    4.不能添加访问修饰符，因为他的地位就是一个局部变量
    5.作用域：仅仅在定义他的方法或代码块中
    6.匿名内部类---访问---->外部类的成员[访问方式：直接访问]
    7.外部其他类---不能访问---->匿名内部类(因为匿名内部类地位是一个局部变量)
    8.如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认就近原则
      ，如果想访问外部类的成员，则可以使用(外部类名.this.成员）去访问

    匿名内部类的最佳实践：当做实参直接传递

# 5.成员内部类的使用
    说明: 成员内部类是定义在外部类的成员位置，并且没有static修饰。
    1.可以直接访问外部类的所有成员，包含私有的
    2.可以添加任意访问修饰符(public、protected、默认、private)，因
      为它的地位就是一个成员
    3.作用域和外部类的其他成员一样，为整个类体，在外部类的成员方法中创建成员内部类对象，
      再调用方法
    4.成员内部类---访问---->外部类的成员[访问方式：直接访问]
    5.外部类---访问---->成员内部类[访问方式：创建对象，再访问]
    6.外部其他类---访问---->成员内部类（参考InnerclassTest02.java）
    7.如果外部类和内部类的成员重名时，内部类访问的话，默认就近原则
      ，如果想访问外部类的成员，则可以使用(外部类名.this.成员）去访问

# 6.静态内部类的使用
     说明: 静态内部类是定义在外部类的成员位置，并且有static修饰。
        1.可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员
        2.可以添加任意访问修饰符(public、protected、默认、private)，因
          为它的地位就是一个成员
        3.作用域：同其他的成员，为整个类体
        4.静态内部类---访问---->外部类（比如：静态属性）[访问方式：直接访问所有静态成员]
        5.外部类---访问---->成员内部类[访问方式：创建对象，再访问]
        6.外部其他类---访问---->静态内部类
        7.如果外部类和静态内部类的成员重名时，内部类访问的话，默认就近原则
          ，如果想访问外部类的成员，则可以使用(外部类名.成员）去访问
